---
title: "LOO_MRP Simulation for AR prior and small area estimation models"
author: "Swen Kuh"
date: "08/04/2022"
output: html_document
---

# Simulation 3/4
## Super-population approach
To test AR prior performance on the three different relationships of X4 and the outcome, and also their performances on small area (group) estimations:
 
```{r}
## relationship of X4 with outcome
fx1 = function(x) {dbeta(x,2,2)}
fx2 = function(x) {1 - dbeta(x, 2,2)}
fx3 = function(x) {0.7 - (3 * exp(-x/0.2))}
```
 
I wrote a wrapper function `gen_dat` so I can easily generate and simulate the data with different specifications on the cluster. The covariate X's now have a `runif(-3, 3)` distribution so we can generate a cleaner relationship between ... :

```{r gen_dat func}
## generating data - 5 continuous predictors/covariates and a binary outcome 
gen_dat <- function(N, fx, samp_size, ITE){
  set.seed(65438)
  
  pn = 100 # number of different population
  seed = round(runif(pn, min=10, max=100000),0) # fixed seed number
  
  ## first generate 100 different population and sample it each time
  # setting fixed seed using array ID (in cluster)
  set.seed(seed[ITE])
  popn_data <- data.frame(X1_cont = runif(N, -3, 3), 
                          X2_cont = runif(N, -3, 3),
                          X3_cont = runif(N, -3, 3), 
                          X4_cont = runif(N, -3, 3))
  
  ## transforming X4_cont to have normalised scale -- for the beta function in fx
  popn_data$X4_tr = (popn_data$X4_cont - min(popn_data$X4_cont))/
    (max(popn_data$X4_cont) - min(popn_data$X4_cont))
  
  wkly1 = 0.1/2
  strg1 = 1/2
  
  summary(popn_data$X4_cont)
  
  ## generating continuous outcome
  # using -1 as the intercept for we have a better spread of y_prob (probability of outcome)
  popn_data$y_prob <- inv_logit_scaled(-1 + wkly1*popn_data$X1_cont + 
                                          strg1*popn_data$X2_cont +
                                          wkly1*popn_data$X3_cont +
                                          1.5*fx(popn_data$X4_tr))
  
  
  ## generating binary outcome
  popn_data$y_obs <- as.numeric(rbinom(N,1,popn_data$y_prob))
  
  ## generate inclusion prob. for each individual
  # weakly predictive - 0.1 (sd), strongly predictive - 1 (sd)
  wkly2 = 0.1
  strg2 = 1
  popn_data$incl_prob <- inv_logit_scaled(wkly2*popn_data$X1_cont + 
                                            wkly2*popn_data$X2_cont + 
                                            strg2*popn_data$X3_cont +
                                            strg2*popn_data$X4_cont)
  
  ## categorising the continuous covariates 
  Q = 5
  K = 12
  popn_data  = popn_data %>% 
    mutate(X1_fct = cut_interval(X1_cont,Q, labels=F),
           X2_fct = cut_interval(X2_cont,Q, labels=F),
           X3_fct = cut_interval(X3_cont,Q, labels=F),
           X4_fct = cut_interval(X4_tr,K, labels=F)) %>%  
    mutate(across(X1_fct:X4_fct, ~ as.factor(.x))) 
  
  popn_data <- popn_data %>% 
    rename(X1 = X1_fct,
           X2 = X2_fct,
           X3 = X3_fct,
           X4 = X4_fct)
  
    
  ## generating samples
  samp_loc = sample(1:nrow(popn_data), size = samp_size-(Q*3 + K), replace=F, prob = popn_data$incl_prob)
  
  ## making sure at least each level of the covariates are sampled
  for(q in 1:Q){
    X1_loc_q = which(popn_data$X1 == q)
    X2_loc_q = which(popn_data$X2 == q)
    X3_loc_q = which(popn_data$X3 == q)
    samp_loc[length(samp_loc)+1] = sample(X1_loc_q, size=1)
    samp_loc[length(samp_loc)+1] = sample(X2_loc_q, size=1)
    samp_loc[length(samp_loc)+1] = sample(X3_loc_q, size=1)
  }
  
  for(k in 1:K){
    if(length(which(popn_data$X4 == k)) == 1 ){ # for when only 1 indv. exist in that popn. level
      samp_loc[length(samp_loc)+1] = which(popn_data$X4 == k)
    } else
      samp_loc[length(samp_loc)+1] = sample(which(popn_data$X4 == k), size=1)
  }
  
  samp_data = popn_data[samp_loc,]

  ## make poststrat table for popn
  popn_ps = popn_data %>% 
    group_by(X1, X2, X3, X4) %>% 
    summarise(Nj = n(), prob_out = mean(y_prob), .groups='drop') %>% 
    ungroup()
  
  all_list <- list(samp_data, popn_ps, popn_data, N, Q, K)
  names(all_list) = c('samp_data', 'popn_ps', 'popn_data', 'N', 'Q', 'K')
  all_list
}
```

